def (root, extension, skel, required) = [file('.').toPath(), '.json', 'template', ['isil']]

def camelize = { it.replaceAll(~/\b./) { it[0].toUpperCase() } }
def taskName = { prefix, name -> prefix + camelize(name).replaceAll('[^a-zA-Z0-9]', '') }

def propTask = { group, list ->
    def prop = "${project.group}.${group}"

    list.each { value ->
        task(taskName(group, value), group: group, description: "Sets -D${prop}=${value}") {
            doLast { System.properties[prop] = value }
        }
    }
}

// See hbz.limetrans.Main.Env.
propTask('env', ['prod', 'dev', 'd7test', 'local', 'ignore'])

file('src/conf').eachDir {
    def (group, path) = [it.getName(), it.toPath()]

    def indexTask = { name, list ->
        task(taskName(group, name), type: JavaExec, group: group, description: list.collect { root.relativize(it.toPath()) }) {
            classpath = sourceSets.main.runtimeClasspath
            mainClass = "${project.group}.Main"
            args list
        }
    }

    def newTask = { source ->
        def name = taskName(group, 'new')
        def groupTask = project.tasks.findByName(name) ?:
            task(name, group: group, description: "Adds new configuration ${required}") {
                doLast {
                    def missing = required.findAll { !project.hasProperty(it) }
                    if (missing) throw new InvalidUserDataException(
                        'Missing ' + missing.collect { "-P${it}=..." })
                }
            }

        groupTask.doLast {
            copy {
                from source
                into path

                rename skel, isil.toLowerCase()
                expand(isil: isil)
            }
        }
    }

    it.eachFileMatch(~/.*\Q${extension}\E/) {
        def name = it.getName().minus(extension)
        name.startsWith(skel) ? newTask(it) : indexTask(name, [it])
    }
}

def execTask = { name, main ->
    task(taskName('exec', name), type: JavaExec, group: 'Exec', description: 'Execute ' + main + '.') {
        classpath = sourceSets.main.runtimeClasspath
        mainClass = main
    }
}

execTask('filter', "${project.group}.filter.Main")
execTask('verify-links', "${project.group}.function.VerifyLinks")
execTask('transformation', "${project.group}.Main")

def (matrixPairs, matrixProduct, matrixMultiply) = [[], []]
testMatrix.each { key, list ->
    list.add(0, '')
    matrixPairs << list.collect() { [key, it] }
}
matrixMultiply = { product, pairs ->
    def tail = pairs.tail()

    pairs.head().each {
        def list = product + [it]
        tail.isEmpty() ? matrixProduct << list : matrixMultiply(list, tail)
    }
}
matrixMultiply([], matrixPairs)

task matrix(group: 'Verification', description: 'Runs all checks for test matrix.') {
    doFirst {
        def (prefix, failed) = ["-P${versionsProperty.prefix}${versionsProperty.separator}", []]

        matrixProduct.each {
            def list = it.collect { "${it[0]}=${it[1]}" }
            def text = list.join(' ')

            def result = exec {
                logger.lifecycle("Matrix: ${text}")

                executable './gradlew'
                ignoreExitValue true

                args '--console=plain', '--no-daemon', 'check'
                args list.collect { "${prefix}${it}" }
            }

            if (result.exitValue != 0) {
                failed << text
            }
        }

        if (!failed.isEmpty()) {
            failed.add(0, "${failed.size()} FAILED:")
            throw new GradleException(failed.join("\n- "))
        }
    }
}
